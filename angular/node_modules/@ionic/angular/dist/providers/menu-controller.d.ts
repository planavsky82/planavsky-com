import * as ɵngcc0 from '@angular/core';
export declare class MenuController {
    /**
     * Programmatically open the Menu.
     * @param [menuId]  Optionally get the menu by its id, or side.
     * @return returns a promise when the menu is fully opened
     */
    open(menuId?: string): Promise<boolean>;
    /**
     * Programmatically close the Menu. If no `menuId` is given as the first
     * argument then it'll close any menu which is open. If a `menuId`
     * is given then it'll close that exact menu.
     * @param [menuId]  Optionally get the menu by its id, or side.
     * @return returns a promise when the menu is fully closed
     */
    close(menuId?: string): Promise<boolean>;
    /**
     * Toggle the menu. If it's closed, it will open, and if opened, it
     * will close.
     * @param [menuId]  Optionally get the menu by its id, or side.
     * @return returns a promise when the menu has been toggled
     */
    toggle(menuId?: string): Promise<boolean>;
    /**
     * Used to enable or disable a menu. For example, there could be multiple
     * left menus, but only one of them should be able to be opened at the same
     * time. If there are multiple menus on the same side, then enabling one menu
     * will also automatically disable all the others that are on the same side.
     * @param [menuId]  Optionally get the menu by its id, or side.
     * @return Returns the instance of the menu, which is useful for chaining.
     */
    enable(shouldEnable: boolean, menuId?: string): Promise<HTMLIonMenuElement | undefined>;
    /**
     * Used to enable or disable the ability to swipe open the menu.
     * @param shouldEnable  True if it should be swipe-able, false if not.
     * @param [menuId]  Optionally get the menu by its id, or side.
     * @return Returns the instance of the menu, which is useful for chaining.
     * @deprecated Use swipeGesture() instead.
     */
    swipeEnable(shouldEnable: boolean, menuId?: string): Promise<HTMLIonMenuElement | undefined>;
    /**
     * Used to enable or disable the ability to swipe open the menu.
     * @param shouldEnable  True if it should be swipe-able, false if not.
     * @param [menuId]  Optionally get the menu by its id, or side.
     * @return Returns the instance of the menu, which is useful for chaining.
     */
    swipeGesture(shouldEnable: boolean, menuId?: string): Promise<HTMLIonMenuElement | undefined>;
    /**
     * @param [menuId] Optionally get the menu by its id, or side.
     * @return Returns true if the specified menu is currently open, otherwise false.
     * If the menuId is not specified, it returns true if ANY menu is currenly open.
     */
    isOpen(menuId?: string): Promise<boolean>;
    /**
     * @param [menuId]  Optionally get the menu by its id, or side.
     * @return Returns true if the menu is currently enabled, otherwise false.
     */
    isEnabled(menuId?: string): Promise<boolean>;
    /**
     * Used to get a menu instance. If a `menuId` is not provided then it'll
     * return the first menu found. If a `menuId` is `left` or `right`, then
     * it'll return the enabled menu on that side. Otherwise, if a `menuId` is
     * provided, then it'll try to find the menu using the menu's `id`
     * property. If a menu is not found then it'll return `null`.
     * @param [menuId]  Optionally get the menu by its id, or side.
     * @return Returns the instance of the menu if found, otherwise `null`.
     */
    get(menuId?: string): Promise<HTMLIonMenuElement | undefined>;
    /**
     * @return Returns the instance of the menu already opened, otherwise `null`.
     */
    getOpen(): Promise<HTMLIonMenuElement | undefined>;
    /**
     * @return Returns an array of all menu instances.
     */
    getMenus(): Promise<HTMLIonMenuElement[]>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<MenuController, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<MenuController>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVudS1jb250cm9sbGVyLmQudHMiLCJzb3VyY2VzIjpbIm1lbnUtY29udHJvbGxlci5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlY2xhcmUgY2xhc3MgTWVudUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIFByb2dyYW1tYXRpY2FsbHkgb3BlbiB0aGUgTWVudS5cbiAgICAgKiBAcGFyYW0gW21lbnVJZF0gIE9wdGlvbmFsbHkgZ2V0IHRoZSBtZW51IGJ5IGl0cyBpZCwgb3Igc2lkZS5cbiAgICAgKiBAcmV0dXJuIHJldHVybnMgYSBwcm9taXNlIHdoZW4gdGhlIG1lbnUgaXMgZnVsbHkgb3BlbmVkXG4gICAgICovXG4gICAgb3BlbihtZW51SWQ/OiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+O1xuICAgIC8qKlxuICAgICAqIFByb2dyYW1tYXRpY2FsbHkgY2xvc2UgdGhlIE1lbnUuIElmIG5vIGBtZW51SWRgIGlzIGdpdmVuIGFzIHRoZSBmaXJzdFxuICAgICAqIGFyZ3VtZW50IHRoZW4gaXQnbGwgY2xvc2UgYW55IG1lbnUgd2hpY2ggaXMgb3Blbi4gSWYgYSBgbWVudUlkYFxuICAgICAqIGlzIGdpdmVuIHRoZW4gaXQnbGwgY2xvc2UgdGhhdCBleGFjdCBtZW51LlxuICAgICAqIEBwYXJhbSBbbWVudUlkXSAgT3B0aW9uYWxseSBnZXQgdGhlIG1lbnUgYnkgaXRzIGlkLCBvciBzaWRlLlxuICAgICAqIEByZXR1cm4gcmV0dXJucyBhIHByb21pc2Ugd2hlbiB0aGUgbWVudSBpcyBmdWxseSBjbG9zZWRcbiAgICAgKi9cbiAgICBjbG9zZShtZW51SWQ/OiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+O1xuICAgIC8qKlxuICAgICAqIFRvZ2dsZSB0aGUgbWVudS4gSWYgaXQncyBjbG9zZWQsIGl0IHdpbGwgb3BlbiwgYW5kIGlmIG9wZW5lZCwgaXRcbiAgICAgKiB3aWxsIGNsb3NlLlxuICAgICAqIEBwYXJhbSBbbWVudUlkXSAgT3B0aW9uYWxseSBnZXQgdGhlIG1lbnUgYnkgaXRzIGlkLCBvciBzaWRlLlxuICAgICAqIEByZXR1cm4gcmV0dXJucyBhIHByb21pc2Ugd2hlbiB0aGUgbWVudSBoYXMgYmVlbiB0b2dnbGVkXG4gICAgICovXG4gICAgdG9nZ2xlKG1lbnVJZD86IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj47XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBlbmFibGUgb3IgZGlzYWJsZSBhIG1lbnUuIEZvciBleGFtcGxlLCB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZVxuICAgICAqIGxlZnQgbWVudXMsIGJ1dCBvbmx5IG9uZSBvZiB0aGVtIHNob3VsZCBiZSBhYmxlIHRvIGJlIG9wZW5lZCBhdCB0aGUgc2FtZVxuICAgICAqIHRpbWUuIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBtZW51cyBvbiB0aGUgc2FtZSBzaWRlLCB0aGVuIGVuYWJsaW5nIG9uZSBtZW51XG4gICAgICogd2lsbCBhbHNvIGF1dG9tYXRpY2FsbHkgZGlzYWJsZSBhbGwgdGhlIG90aGVycyB0aGF0IGFyZSBvbiB0aGUgc2FtZSBzaWRlLlxuICAgICAqIEBwYXJhbSBbbWVudUlkXSAgT3B0aW9uYWxseSBnZXQgdGhlIG1lbnUgYnkgaXRzIGlkLCBvciBzaWRlLlxuICAgICAqIEByZXR1cm4gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgdGhlIG1lbnUsIHdoaWNoIGlzIHVzZWZ1bCBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgZW5hYmxlKHNob3VsZEVuYWJsZTogYm9vbGVhbiwgbWVudUlkPzogc3RyaW5nKTogUHJvbWlzZTxIVE1MSW9uTWVudUVsZW1lbnQgfCB1bmRlZmluZWQ+O1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZW5hYmxlIG9yIGRpc2FibGUgdGhlIGFiaWxpdHkgdG8gc3dpcGUgb3BlbiB0aGUgbWVudS5cbiAgICAgKiBAcGFyYW0gc2hvdWxkRW5hYmxlICBUcnVlIGlmIGl0IHNob3VsZCBiZSBzd2lwZS1hYmxlLCBmYWxzZSBpZiBub3QuXG4gICAgICogQHBhcmFtIFttZW51SWRdICBPcHRpb25hbGx5IGdldCB0aGUgbWVudSBieSBpdHMgaWQsIG9yIHNpZGUuXG4gICAgICogQHJldHVybiBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiB0aGUgbWVudSwgd2hpY2ggaXMgdXNlZnVsIGZvciBjaGFpbmluZy5cbiAgICAgKiBAZGVwcmVjYXRlZCBVc2Ugc3dpcGVHZXN0dXJlKCkgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBzd2lwZUVuYWJsZShzaG91bGRFbmFibGU6IGJvb2xlYW4sIG1lbnVJZD86IHN0cmluZyk6IFByb21pc2U8SFRNTElvbk1lbnVFbGVtZW50IHwgdW5kZWZpbmVkPjtcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZSBhYmlsaXR5IHRvIHN3aXBlIG9wZW4gdGhlIG1lbnUuXG4gICAgICogQHBhcmFtIHNob3VsZEVuYWJsZSAgVHJ1ZSBpZiBpdCBzaG91bGQgYmUgc3dpcGUtYWJsZSwgZmFsc2UgaWYgbm90LlxuICAgICAqIEBwYXJhbSBbbWVudUlkXSAgT3B0aW9uYWxseSBnZXQgdGhlIG1lbnUgYnkgaXRzIGlkLCBvciBzaWRlLlxuICAgICAqIEByZXR1cm4gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgdGhlIG1lbnUsIHdoaWNoIGlzIHVzZWZ1bCBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgc3dpcGVHZXN0dXJlKHNob3VsZEVuYWJsZTogYm9vbGVhbiwgbWVudUlkPzogc3RyaW5nKTogUHJvbWlzZTxIVE1MSW9uTWVudUVsZW1lbnQgfCB1bmRlZmluZWQ+O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBbbWVudUlkXSBPcHRpb25hbGx5IGdldCB0aGUgbWVudSBieSBpdHMgaWQsIG9yIHNpZGUuXG4gICAgICogQHJldHVybiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBtZW51IGlzIGN1cnJlbnRseSBvcGVuLCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICogSWYgdGhlIG1lbnVJZCBpcyBub3Qgc3BlY2lmaWVkLCBpdCByZXR1cm5zIHRydWUgaWYgQU5ZIG1lbnUgaXMgY3VycmVubHkgb3Blbi5cbiAgICAgKi9cbiAgICBpc09wZW4obWVudUlkPzogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPjtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gW21lbnVJZF0gIE9wdGlvbmFsbHkgZ2V0IHRoZSBtZW51IGJ5IGl0cyBpZCwgb3Igc2lkZS5cbiAgICAgKiBAcmV0dXJuIFJldHVybnMgdHJ1ZSBpZiB0aGUgbWVudSBpcyBjdXJyZW50bHkgZW5hYmxlZCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgICAqL1xuICAgIGlzRW5hYmxlZChtZW51SWQ/OiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+O1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZ2V0IGEgbWVudSBpbnN0YW5jZS4gSWYgYSBgbWVudUlkYCBpcyBub3QgcHJvdmlkZWQgdGhlbiBpdCdsbFxuICAgICAqIHJldHVybiB0aGUgZmlyc3QgbWVudSBmb3VuZC4gSWYgYSBgbWVudUlkYCBpcyBgbGVmdGAgb3IgYHJpZ2h0YCwgdGhlblxuICAgICAqIGl0J2xsIHJldHVybiB0aGUgZW5hYmxlZCBtZW51IG9uIHRoYXQgc2lkZS4gT3RoZXJ3aXNlLCBpZiBhIGBtZW51SWRgIGlzXG4gICAgICogcHJvdmlkZWQsIHRoZW4gaXQnbGwgdHJ5IHRvIGZpbmQgdGhlIG1lbnUgdXNpbmcgdGhlIG1lbnUncyBgaWRgXG4gICAgICogcHJvcGVydHkuIElmIGEgbWVudSBpcyBub3QgZm91bmQgdGhlbiBpdCdsbCByZXR1cm4gYG51bGxgLlxuICAgICAqIEBwYXJhbSBbbWVudUlkXSAgT3B0aW9uYWxseSBnZXQgdGhlIG1lbnUgYnkgaXRzIGlkLCBvciBzaWRlLlxuICAgICAqIEByZXR1cm4gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgdGhlIG1lbnUgaWYgZm91bmQsIG90aGVyd2lzZSBgbnVsbGAuXG4gICAgICovXG4gICAgZ2V0KG1lbnVJZD86IHN0cmluZyk6IFByb21pc2U8SFRNTElvbk1lbnVFbGVtZW50IHwgdW5kZWZpbmVkPjtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIHRoZSBtZW51IGFscmVhZHkgb3BlbmVkLCBvdGhlcndpc2UgYG51bGxgLlxuICAgICAqL1xuICAgIGdldE9wZW4oKTogUHJvbWlzZTxIVE1MSW9uTWVudUVsZW1lbnQgfCB1bmRlZmluZWQ+O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgbWVudSBpbnN0YW5jZXMuXG4gICAgICovXG4gICAgZ2V0TWVudXMoKTogUHJvbWlzZTxIVE1MSW9uTWVudUVsZW1lbnRbXT47XG59XG4iXX0=